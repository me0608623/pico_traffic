<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§äº¤é€šç‡ˆæ§åˆ¶ç³»çµ± v4.0 - Three.js Tesla Cybertruck</title>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --accent-cyan: #00d4ff;
            --accent-purple: #a855f7;
            --red-on: #ff2d2d;
            --yellow-on: #ffd000;
            --green-on: #00ff5a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 20px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 0.95rem;
            color: var(--text-secondary);
            letter-spacing: 2px;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr 380px;
            gap: 25px;
            align-items: start;
        }

        /* å·¦å´æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-cyan);
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .traffic-control-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .slider-label span:first-child {
            font-weight: 600;
        }

        .traffic-value {
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .traffic-value.low {
            background: rgba(0, 255, 90, 0.2);
            color: var(--green-on);
        }

        .traffic-value.medium {
            background: rgba(255, 208, 0, 0.2);
            color: var(--yellow-on);
        }

        .traffic-value.high {
            background: rgba(255, 45, 45, 0.2);
            color: var(--red-on);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .submit-button {
            padding: 15px 25px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            letter-spacing: 1px;
        }

        .submit-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.5);
        }

        .submit-button:active {
            transform: translateY(0);
        }

        .submit-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .test-buttons-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .test-button {
            padding: 12px 15px;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
        }

        .test-button-ns {
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .test-button-ns:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(52, 152, 219, 0.5);
            background: linear-gradient(135deg, #2980b9, #21618c);
        }

        .test-button-ew {
            background: linear-gradient(135deg, #e67e22, #d68910);
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.3);
        }

        .test-button-ew:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(230, 126, 34, 0.5);
            background: linear-gradient(135deg, #d68910, #ba7506);
        }

        .test-button:active {
            transform: translateY(0);
        }

        .test-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* é€£ç·šè¨­å®š */
        .connection-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            margin-bottom: 20px;
        }

        .ip-input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ip-input-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .ip-input {
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: 'Orbitron', monospace;
            transition: all 0.3s ease;
            outline: none;
        }

        .ip-input:focus {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
        }

        .ip-input::placeholder {
            color: rgba(136, 136, 160, 0.5);
        }

        /* æ¨¡å‹é¸æ“‡å™¨ */
        .model-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .model-select {
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            outline: none;
        }

        .model-select:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 0, 0, 0.5);
        }

        .model-select:focus {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .model-select option {
            background: var(--bg-dark);
            color: var(--text-primary);
            padding: 10px;
        }

        .model-info {
            padding: 10px 15px;
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid var(--accent-cyan);
            border-radius: 4px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* ä¸­é–“ Three.js å ´æ™¯ */
        .scene-wrapper {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            position: relative;
            height: 700px;
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #f0f0f0;
            display: block;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 8px;
            flex-direction: column;
            gap: 20px;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(0, 212, 255, 0.2);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--accent-cyan);
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* å³å´é¢æ¿ */
        .response-panel {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-secondary);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--green-on);
        }

        .status-dot.error {
            background: var(--red-on);
        }

        .status-dot.processing {
            background: var(--yellow-on);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-text {
            font-size: 0.95rem;
            color: var(--text-primary);
        }

        .gpt-response {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
        }

        .gpt-response-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-purple);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gpt-response-content {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-primary);
            white-space: pre-wrap;
        }

        .gpt-response-content.placeholder {
            color: var(--text-secondary);
            font-style: italic;
        }

        .countdown-container {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .countdown-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .countdown-value {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--accent-cyan);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .traffic-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent-cyan);
        }

        .history-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }

        #history-list {
            flex: 1;
            overflow-y: auto;
            max-height: 300px;
        }

        .history-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid var(--accent-cyan);
            font-size: 0.85rem;
        }

        .history-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        /* é‡ç½®æŒ‰éˆ• */
        .reset-button {
            position: fixed;
            bottom: 30px;
            left: 30px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            z-index: 1000;
            letter-spacing: 0.5px;
        }

        .reset-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(231, 76, 60, 0.5);
        }

        .reset-button:active {
            transform: translateY(0);
        }

        footer {
            text-align: center;
            padding: 30px 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
            letter-spacing: 1px;
        }

        @media (max-width: 1400px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .scene-wrapper {
                height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸš¦ Smart Traffic Control</h1>
            <p class="subtitle">Three.js Tesla Cybertruck Traffic Simulation</p>
        </header>

        <div class="main-layout">
            <!-- å·¦å´æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <div class="panel-title">Pico W é€£ç·šè¨­å®š</div>
                
                <div class="connection-section">
                    <div class="ip-input-group">
                        <label for="pico-ip-input">IP ä½å€ï¼š</label>
                        <input type="text" id="pico-ip-input" class="ip-input" 
                               value="10.207.59.163" placeholder="ä¾‹å¦‚ï¼š192.168.1.100">
                    </div>
                    <div class="ip-input-group">
                        <label for="pico-port-input">é€£æ¥åŸ ï¼š</label>
                        <input type="text" id="pico-port-input" class="ip-input" 
                               value="80" placeholder="80">
                    </div>
                </div>

                <div class="panel-title">è»Šæµé‡æ§åˆ¶</div>
                
                <div class="traffic-control-section">
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>ğŸ”¼ åŒ—å‘</span>
                            <span class="traffic-value low" id="north-value">ä½</span>
                        </div>
                        <input type="range" min="0" max="2" value="0" id="north-slider" 
                               oninput="updateTrafficValue('north', this.value)">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>ğŸ”½ å—å‘</span>
                            <span class="traffic-value low" id="south-value">ä½</span>
                        </div>
                        <input type="range" min="0" max="2" value="0" id="south-slider" 
                               oninput="updateTrafficValue('south', this.value)">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>â–¶ï¸ æ±å‘</span>
                            <span class="traffic-value low" id="east-value">ä½</span>
                        </div>
                        <input type="range" min="0" max="2" value="0" id="east-slider" 
                               oninput="updateTrafficValue('east', this.value)">
                    </div>

                    <div class="slider-control">
                        <div class="slider-label">
                            <span>â—€ï¸ è¥¿å‘</span>
                            <span class="traffic-value low" id="west-value">ä½</span>
                        </div>
                        <input type="range" min="0" max="2" value="0" id="west-slider" 
                               oninput="updateTrafficValue('west', this.value)">
                    </div>
                </div>

                <button class="submit-button" id="submit-btn" onclick="submitTrafficData()">
                    ğŸ“¡ ç™¼é€è‡³ Pico W
                </button>

                <div class="test-buttons-group">
                    <button class="test-button test-button-ns" onclick="testTrafficFlow('north-south')">
                        â¬ æ¸¬è©¦å—åŒ—å‘
                    </button>
                    <button class="test-button test-button-ew" onclick="testTrafficFlow('east-west')">
                        â¬Œ æ¸¬è©¦æ±è¥¿å‘
                    </button>
                </div>

                <div class="model-selector">
                    <div class="panel-title">è»Šè¼›æ¨¡å‹é¸æ“‡</div>
                    <select id="model-selector" class="model-select" onchange="switchModel(this.value)">
                        <option value="tesla_cybertruck.glb">Tesla Cybertruck (é è¨­)</option>
                        <option value="tesla_cybertruck1.glb">Tesla Cybertruck 1</option>
                        <option value="tesla_cybertruck2.glb">Tesla Cybertruck 2</option>
                        <option value="tesla_cybertruck3.glb">Tesla Cybertruck 3</option>
                    </select>
                    <div class="model-info" id="model-info">
                        ç•¶å‰æ¨¡å‹ï¼štesla_cybertruck.glb
                    </div>
                </div>
            </div>

            <!-- ä¸­é–“ Three.js å ´æ™¯ -->
            <div class="scene-wrapper">
                <canvas id="three-canvas"></canvas>
                <div class="loading-overlay" id="loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">è¼‰å…¥ Tesla Cybertruck æ¨¡å‹ä¸­...</div>
                </div>
            </div>

            <!-- å³å´é¢æ¿ -->
            <div class="response-panel">
                <div class="panel-title">ç³»çµ±ç‹€æ…‹</div>
                
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span class="status-text" id="status-text">ç­‰å¾…è¨­å®šè»Šæµé‡...</span>
                </div>

                <div class="gpt-response">
                    <div class="gpt-response-title">
                        <span>ğŸ¤–</span>
                        GPT å›æ‡‰
                    </div>
                    <div class="gpt-response-content placeholder" id="gpt-content">
                        ç­‰å¾… AI æ±ºç­–æŒ‡ä»¤...
                    </div>
                </div>

                <div class="countdown-container">
                    <div class="countdown-label">ç•¶å‰ç‡ˆè™Ÿå‰©é¤˜æ™‚é–“</div>
                    <div class="countdown-value" id="countdown">--</div>
                </div>

                <div class="traffic-stats">
                    <div class="panel-title">ç•¶å‰ç‡ˆè™Ÿç‹€æ…‹</div>
                    <div class="stat-item">
                        <span class="stat-label">ğŸ”¼ åŒ—å‘</span>
                        <span class="stat-value" id="light-status-north" style="color: #ff2d2d;">ğŸ”´</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ğŸ”½ å—å‘</span>
                        <span class="stat-value" id="light-status-south" style="color: #ff2d2d;">ğŸ”´</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">â–¶ï¸ æ±å‘</span>
                        <span class="stat-value" id="light-status-east" style="color: #ff2d2d;">ğŸ”´</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">â—€ï¸ è¥¿å‘</span>
                        <span class="stat-value" id="light-status-west" style="color: #ff2d2d;">ğŸ”´</span>
                    </div>
                </div>

                <div class="history-section">
                    <div class="panel-title">æ“ä½œç´€éŒ„</div>
                    <div id="history-list"></div>
                </div>
            </div>
        </div>

        <footer>
            æ™ºæ…§äº¤é€šç‡ˆæ§åˆ¶ç³»çµ± v4.0 | Three.js Tesla Cybertruck | Powered by Pico W + GPT
        </footer>

        <button class="reset-button" onclick="resetAllVehicles()">
            ğŸ”„ é‡ç½®æ‰€æœ‰è»Šè¼›
        </button>
    </div>

    <script type="module">
        // ============================================
        // Three.js æ¨¡çµ„å¼•å…¥
        // ============================================
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // å…¨åŸŸå¸¸æ•¸èˆ‡é…ç½®
        // ============================================
        // Pico W IP ç¾åœ¨å¾è¼¸å…¥æ¬„ä½è®€å–
        function getPicoIP() {
            return document.getElementById('pico-ip-input')?.value || '10.207.59.163';
        }
        
        function getPicoPort() {
            return document.getElementById('pico-port-input')?.value || '80';
        }
        
        const trafficLevels = ['low', 'medium', 'high'];
        const trafficLabels = { low: 'ä½', medium: 'ä¸­', high: 'é«˜' };
        
        const SPAWN_RATE = {
            low: 3000,      // å¾ 2000 å¢åŠ åˆ° 3000ï¼ˆå¢åŠ é–“è·ï¼‰
            medium: 1500,  // å¾ 1000 å¢åŠ åˆ° 1500ï¼ˆå¢åŠ é–“è·ï¼‰
            high: 800      // å¾ 500 å¢åŠ åˆ° 800ï¼ˆå¢åŠ é–“è·ï¼‰
        };

        // ============================================
        // Three.js å ´æ™¯è¨­ç½®
        // ============================================
        let scene, camera, renderer, controls;
        let cybertruckModel = null; // åŸå§‹æ¨¡å‹
        let vehicles = []; // å ´æ™¯ä¸­çš„è»Šè¼›å¯¦ä¾‹
        let roadMesh, intersectionGroup;
        let currentModelPath = 'tesla_cybertruck.glb'; // ç•¶å‰ä½¿ç”¨çš„æ¨¡å‹è·¯å¾‘
        
        // ä¸åŒæ¨¡å‹çš„æ—‹è½‰è£œå„Ÿï¼ˆæ¯å€‹æ¨¡å‹çš„é è¨­æœå‘å¯èƒ½ä¸åŒï¼‰
        // å¯ä»¥é‡å°ä¸åŒæ–¹å‘è¨­å®šä¸åŒçš„è£œå„Ÿ
        const modelRotationOffset = {
            'tesla_cybertruck.glb': { 
                all: 0,                                       // å…¨å±€è£œå„Ÿ
                north: Math.PI,                                // åŒ—å‘é¡å¤–è£œå„Ÿï¼š180åº¦
                south: Math.PI                                 // å—å‘é¡å¤–è£œå„Ÿï¼š180åº¦
            },
            'tesla_cybertruck1.glb': { all: 0 },             // æ¨¡å‹1
            'tesla_cybertruck2.glb': { 
                all: Math.PI / 2,                            // å…¨å±€è£œå„Ÿï¼šé€†æ™‚é‡90åº¦
                east: Math.PI,                                // æ±å‘é¡å¤–è£œå„Ÿï¼š180åº¦
                west: Math.PI                                 // è¥¿å‘é¡å¤–è£œå„Ÿï¼š180åº¦
            },
            'tesla_cybertruck3.glb': { 
                all: -Math.PI / 2,                           // å…¨å±€è£œå„Ÿï¼šé †æ™‚é‡90åº¦
                north: Math.PI,                              // åŒ—å‘é¡å¤–è£œå„Ÿï¼š180åº¦
                south: Math.PI                               // å—å‘é¡å¤–è£œå„Ÿï¼š180åº¦
            }
        };
        
        // ä¸åŒæ¨¡å‹çš„é«˜åº¦åç§»ï¼ˆYåº§æ¨™ï¼‰
        const modelHeightOffset = {
            'tesla_cybertruck.glb': 1.0,     // é è¨­æ¨¡å‹éœ€è¦æå‡é«˜åº¦ï¼ˆé¿å…ä¸€åŠåœ¨åœ°åº•ï¼‰
            'tesla_cybertruck1.glb': 0,      // æ¨¡å‹1
            'tesla_cybertruck2.glb': 0,      // æ¨¡å‹2
            'tesla_cybertruck3.glb': 0       // æ¨¡å‹3
        };

        function initThreeJS() {
            const canvas = document.getElementById('three-canvas');
            const wrapper = canvas.parentElement;
            
            // å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 50, 200);
            
            // ç›¸æ©Ÿ
            const aspect = wrapper.clientWidth / wrapper.clientHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.set(0, 50, 70);
            camera.lookAt(0, 0, 0);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // ç‡ˆå…‰ - AmbientLightï¼ˆç’°å¢ƒå…‰ï¼‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // ç‡ˆå…‰ - DirectionalLightï¼ˆæ–¹å‘å…‰ï¼‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 80, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -60;
            directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60;
            directionalLight.shadow.camera.bottom = -60;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // é¡å¤–çš„å¡«å……å…‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-50, 30, -50);
            scene.add(fillLight);
            
            // OrbitControlsï¼ˆè»Œé“æ§åˆ¶ï¼‰
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 150;
            controls.maxPolarAngle = Math.PI / 2.2;
            
            // å‰µå»ºè·¯å£å ´æ™¯
            createIntersection();
            
            // RWD éŸ¿æ‡‰
            window.addEventListener('resize', onWindowResize, false);
            
            // è¼‰å…¥ Tesla Cybertruck æ¨¡å‹
            loadCybertruckModel();
            
            // é–‹å§‹æ¸²æŸ“å¾ªç’°
            animate();
        }

        function createIntersection() {
            intersectionGroup = new THREE.Group();
            
            // åœ°é¢ï¼ˆè‰åœ°ï¼‰
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            intersectionGroup.add(ground);
            
            // é“è·¯ï¼ˆåå­—è·¯å£ï¼‰
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                roughness: 0.8 
            });
            
            // æ°´å¹³é“è·¯
            const roadH = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 20),
                roadMaterial
            );
            roadH.rotation.x = -Math.PI / 2;
            roadH.receiveShadow = true;
            intersectionGroup.add(roadH);
            
            // å‚ç›´é“è·¯
            const roadV = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 80),
                roadMaterial
            );
            roadV.rotation.x = -Math.PI / 2;
            roadV.receiveShadow = true;
            intersectionGroup.add(roadV);
            
            // é“è·¯æ¨™ç·š
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            // ä¸­å¤®è™›ç·šï¼ˆæ°´å¹³ï¼‰
            for (let i = -35; i <= 35; i += 5) {
                const line = new THREE.Mesh(
                    new THREE.PlaneGeometry(3, 0.3),
                    lineMaterial
                );
                line.rotation.x = -Math.PI / 2;
                line.position.set(i, 0.01, 0);
                intersectionGroup.add(line);
            }
            
            // ä¸­å¤®è™›ç·šï¼ˆå‚ç›´ï¼‰
            for (let i = -35; i <= 35; i += 5) {
                const line = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, 3),
                    lineMaterial
                );
                line.rotation.x = -Math.PI / 2;
                line.position.set(0, 0.01, i);
                intersectionGroup.add(line);
            }
            
            // ç´…ç¶ ç‡ˆæŸ±ï¼ˆç°¡åŒ–ç‰ˆï¼‰
            createTrafficLight(-12, -12, 'north');
            createTrafficLight(-12, 12, 'south');
            createTrafficLight(12, -12, 'east');
            createTrafficLight(12, 12, 'west');
            
            // ç¹ªè£½åœæ­¢ç·š
            createStopLines();
            
            scene.add(intersectionGroup);
        }

        function createStopLines() {
            // åœæ­¢ç·šæè³ªï¼ˆç™½è‰²ï¼Œç¨å¾®ç™¼å…‰ï¼‰
            const stopLineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            // åœæ­¢ç·šä½ç½®å°æ‡‰ä»£ç¢¼ä¸­çš„ stopLines
            // north: -12, south: 12, east: 10, west: -10
            
            // åŒ—å‘åœæ­¢ç·šï¼ˆæ©«å‘ï¼Œä½æ–¼ z=-12ï¼‰
            const stopLineNorth = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 0.3),
                stopLineMaterial
            );
            stopLineNorth.rotation.x = -Math.PI / 2;
            stopLineNorth.position.set(3, 0.02, -12);
            intersectionGroup.add(stopLineNorth);
            
            // å—å‘åœæ­¢ç·šï¼ˆæ©«å‘ï¼Œä½æ–¼ z=12ï¼‰
            const stopLineSouth = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 0.3),
                stopLineMaterial
            );
            stopLineSouth.rotation.x = -Math.PI / 2;
            stopLineSouth.position.set(-3, 0.02, 12);
            intersectionGroup.add(stopLineSouth);
            
            // æ±å‘åœæ­¢ç·šï¼ˆç¸±å‘ï¼Œä½æ–¼ x=10ï¼Œè»Šè¼›å¾å³é‚Šä¾†ï¼Œåœåœ¨å³å´ï¼‰
            const stopLineEast = new THREE.Mesh(
                new THREE.PlaneGeometry(0.3, 6),
                stopLineMaterial
            );
            stopLineEast.rotation.x = -Math.PI / 2;
            stopLineEast.position.set(10, 0.02, 5);  // zåº§æ¨™å¾3æ”¹ç‚º5ï¼Œå°æ‡‰æ–°è»Šé“ä½ç½®
            intersectionGroup.add(stopLineEast);
            
            // è¥¿å‘åœæ­¢ç·šï¼ˆç¸±å‘ï¼Œä½æ–¼ x=-10ï¼Œè»Šè¼›å¾å·¦é‚Šä¾†ï¼Œåœåœ¨å·¦å´ï¼‰
            const stopLineWest = new THREE.Mesh(
                new THREE.PlaneGeometry(0.3, 6),
                stopLineMaterial
            );
            stopLineWest.rotation.x = -Math.PI / 2;
            stopLineWest.position.set(-10, 0.02, -5);  // zåº§æ¨™å¾-3æ”¹ç‚º-5ï¼Œå°æ‡‰æ–°è»Šé“ä½ç½®
            intersectionGroup.add(stopLineWest);
        }

        function createTrafficLight(x, z, direction) {
            // å‰µå»ºç´…ç¶ ç‡ˆçµ„ï¼ˆåŒ…å«ç‡ˆç®±å’Œç‡ˆå…‰ï¼‰
            const trafficLightGroup = new THREE.Group();
            trafficLightGroup.position.set(x, 0, z);
            
            // æ ¹æ“šæ–¹å‘è¨­ç½®æ—‹è½‰
            const rotations = {
                north: 0,              // é¢å‘å—ï¼ˆ0åº¦ï¼‰
                south: Math.PI,        // é¢å‘åŒ—ï¼ˆ180åº¦ï¼‰
                east: Math.PI / 2,     // é¢å‘è¥¿ï¼ˆ90åº¦ï¼‰
                west: -Math.PI / 2     // é¢å‘æ±ï¼ˆ-90åº¦ï¼‰
            };
            trafficLightGroup.rotation.y = rotations[direction] || 0;
            
            // ç‡ˆæŸ±
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 4;
            pole.castShadow = true;
            trafficLightGroup.add(pole);
            
            // ç‡ˆç®±
            const lightBoxGeometry = new THREE.BoxGeometry(1, 3, 0.5);
            const lightBoxMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const lightBox = new THREE.Mesh(lightBoxGeometry, lightBoxMaterial);
            lightBox.position.y = 8.5;
            lightBox.castShadow = true;
            trafficLightGroup.add(lightBox);
            
            // ç´…ç‡ˆï¼ˆåˆå§‹äº®èµ·ï¼‰
            const lightRed = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, 
                    emissive: 0xff0000,
                    emissiveIntensity: 1
                })
            );
            lightRed.position.set(0, 9.5, 0.3);
            lightRed.userData = { type: 'red', direction, isOn: true };
            trafficLightGroup.add(lightRed);
            
            // é»ƒç‡ˆï¼ˆåˆå§‹é—œé–‰ï¼‰
            const lightYellow = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x333300,
                    emissive: 0x000000
                })
            );
            lightYellow.position.set(0, 8.5, 0.3);
            lightYellow.userData = { type: 'yellow', direction, isOn: false };
            trafficLightGroup.add(lightYellow);
            
            // ç¶ ç‡ˆï¼ˆåˆå§‹é—œé–‰ï¼‰
            const lightGreen = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x003300,
                    emissive: 0x000000
                })
            );
            lightGreen.position.set(0, 7.5, 0.3);
            lightGreen.userData = { type: 'green', direction, isOn: false };
            trafficLightGroup.add(lightGreen);
            
            intersectionGroup.add(trafficLightGroup);
        }

        function loadCybertruckModel(modelFileName = 'tesla_cybertruck.glb') {
            const loader = new GLTFLoader();
            currentModelPath = modelFileName;
            
            // å˜—è©¦å¤šå€‹å¯èƒ½çš„è·¯å¾‘
            const modelPaths = [
                `./${modelFileName}`,
                modelFileName,
                `/${modelFileName}`
            ];
            
            let currentPathIndex = 0;
            
            function tryLoadModel() {
                const currentPath = modelPaths[currentPathIndex];
                console.log(`å˜—è©¦è¼‰å…¥æ¨¡å‹: ${currentPath}`);
                
                loader.load(
                    currentPath,
                    (gltf) => {
                        console.log('âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸï¼', gltf);
                        cybertruckModel = gltf.scene;
                        
                        // èª¿æ•´æ¨¡å‹å¤§å°ï¼ˆæ”¾å¤§è»Šè¼›ï¼‰
                        const box = new THREE.Box3().setFromObject(cybertruckModel);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 5 / maxDim; // å¢åŠ åˆ° 5ï¼ˆåŸæœ¬æ˜¯ 3ï¼‰è®“è»Šå­æ›´å¤§
                        cybertruckModel.scale.set(scale, scale, scale);
                        
                        console.log('æ¨¡å‹å°ºå¯¸:', size, 'ç¸®æ”¾æ¯”ä¾‹:', scale);
                        
                        // å•Ÿç”¨é™°å½±
                        cybertruckModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                // ç¢ºä¿æè³ªæ­£ç¢º
                                if (child.material) {
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                        
                        // éš±è—è¼‰å…¥ç•«é¢
                        document.getElementById('loading').classList.add('hidden');
                        addHistory('âœ… Tesla Cybertruck æ¨¡å‹è¼‰å…¥æˆåŠŸ');
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(0);
                            const loadingText = document.querySelector('.loading-text');
                            if (loadingText) {
                                loadingText.textContent = `è¼‰å…¥æ¨¡å‹ä¸­... ${percent}%`;
                            }
                            console.log(`è¼‰å…¥é€²åº¦: ${percent}%`);
                        }
                    },
                    (error) => {
                        console.error(`è·¯å¾‘ ${currentPath} è¼‰å…¥å¤±æ•—:`, error);
                        
                        // å˜—è©¦ä¸‹ä¸€å€‹è·¯å¾‘
                        currentPathIndex++;
                        if (currentPathIndex < modelPaths.length) {
                            console.log('å˜—è©¦ä¸‹ä¸€å€‹è·¯å¾‘...');
                            tryLoadModel();
                        } else {
                            // æ‰€æœ‰è·¯å¾‘éƒ½å¤±æ•—ï¼Œä½¿ç”¨å‚™ç”¨æ–¹æ¡ˆ
                            console.error('æ‰€æœ‰è·¯å¾‘éƒ½è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨å‚™ç”¨æ–¹å¡Š');
                            const loadingText = document.querySelector('.loading-text');
                            if (loadingText) {
                                loadingText.textContent = 'âš ï¸ ä½¿ç”¨ç°¡åŒ–æ–¹å¡Šä»£æ›¿ï¼ˆæ¨¡å‹è¼‰å…¥å¤±æ•—ï¼‰';
                                loadingText.style.color = '#ffd000';
                            }
                            addHistory('âš ï¸ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨ç°¡åŒ–æ–¹å¡Šä»£æ›¿');
                            
                            // ä½¿ç”¨ç°¡å–®æ–¹å¡Šä½œç‚ºå‚™ç”¨
                            const boxGeometry = new THREE.BoxGeometry(3, 1.5, 5);
                            const boxMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x888888,
                                metalness: 0.5,
                                roughness: 0.5
                            });
                            cybertruckModel = new THREE.Mesh(boxGeometry, boxMaterial);
                            cybertruckModel.castShadow = true;
                            cybertruckModel.receiveShadow = true;
                            
                            setTimeout(() => {
                                document.getElementById('loading').classList.add('hidden');
                            }, 2000);
                        }
                    }
                );
            }
            
            // é–‹å§‹è¼‰å…¥
            tryLoadModel();
        }

        function onWindowResize() {
            const wrapper = document.querySelector('.scene-wrapper');
            const width = wrapper.clientWidth;
            const height = wrapper.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateAllVehicles();
            renderer.render(scene, camera);
        }

        // ============================================
        // è»Šè¼›ç®¡ç†ç³»çµ±
        // ============================================
        let nextVehicleId = 0;
        let spawnIntervals = {};
        let systemStarted = false;
        let trafficLightStatus = {
            north: 'red',
            south: 'red',
            east: 'red',
            west: 'red'
        };
        let currentTrafficLevels = {
            north: 'low',
            south: 'low',
            east: 'low',
            west: 'low'
        };

        class Vehicle {
            constructor(id, direction) {
                this.id = id;
                this.direction = direction;
                this.speed = 0;
                this.maxSpeed = 0.5;
                this.acceleration = 0.02;
                this.deceleration = 0.04;
                
                // Three.js å°è±¡
                if (cybertruckModel) {
                    this.mesh = cybertruckModel.clone();
                    this.mesh.userData = { vehicleId: id, direction };
                    scene.add(this.mesh);
                    
                    // è¨­ç½®åˆå§‹ä½ç½®å’Œæ—‹è½‰
                    this.setInitialTransform();
                    
                    // ç«‹å³æª¢æŸ¥ç´…ç¶ ç‡ˆç‹€æ…‹ä¸¦åŸ·è¡Œé¦–æ¬¡æ›´æ–°
                    const lightStatus = trafficLightStatus[this.direction];
                    if (lightStatus === 'red' || lightStatus === 'yellow') {
                        this.speed = 0; // ç¢ºä¿ç´…ç‡ˆæ–¹å‘çš„è»Šè¼›ç”Ÿæˆæ™‚é€Ÿåº¦ç‚º0
                        console.log(`ğŸš— è»Š ${this.id} (${this.direction}) ç”Ÿæˆæ–¼${lightStatus}ç‡ˆï¼Œåˆå§‹é€Ÿåº¦=0ï¼Œåœåœ¨ç´…ç‡ˆå‰`);
                    } else {
                        // ç¶ ç‡ˆæ™‚å¯ä»¥çµ¦åˆå§‹é€Ÿåº¦
                        this.speed = this.acceleration;
                    }
                }
            }

            setInitialTransform() {
                // åŸºç¤æ—‹è½‰è§’åº¦ï¼ˆæ ¹æ“šé è¨­æ¨¡å‹1èª¿æ•´ï¼‰
                const baseRotations = {
                    north: -Math.PI / 2,         // å‘å—è¡Œé§›ï¼ˆæœå—ï¼‰-90åº¦
                    south: Math.PI / 2,          // å‘åŒ—è¡Œé§›ï¼ˆæœåŒ—ï¼‰90åº¦
                    east: 0,                     // å‘è¥¿è¡Œé§›ï¼ˆæœè¥¿ï¼‰0åº¦
                    west: Math.PI                // å‘æ±è¡Œé§›ï¼ˆæœæ±ï¼‰180åº¦
                };
                
                // æ ¹æ“šç•¶å‰æ¨¡å‹æ·»åŠ é¡å¤–çš„æ—‹è½‰è£œå„Ÿ
                const modelOffset = modelRotationOffset[currentModelPath] || { all: 0 };
                const baseExtraRotation = modelOffset.all || 0;
                
                // é‡å°ç‰¹å®šæ–¹å‘çš„é¡å¤–è£œå„Ÿ
                const directionExtraRotation = modelOffset[this.direction] || 0;
                const totalExtraRotation = baseExtraRotation + directionExtraRotation;
                
                const paths = {
                    north: { x: 3, z: -40, rotation: baseRotations.north + totalExtraRotation },
                    south: { x: -3, z: 40, rotation: baseRotations.south + totalExtraRotation },
                    east: { x: 40, z: 5, rotation: baseRotations.east + totalExtraRotation },    // å¾ z:3 æ”¹ç‚º z:5ï¼ˆå¢åŠ é–“è·ï¼‰
                    west: { x: -40, z: -5, rotation: baseRotations.west + totalExtraRotation }   // å¾ z:-3 æ”¹ç‚º z:-5ï¼ˆå¢åŠ é–“è·ï¼‰
                };
                
                const path = paths[this.direction];
                if (this.mesh && path) {
                    // æ ¹æ“šæ¨¡å‹é¡å‹è¨­ç½®é«˜åº¦åç§»
                    const heightOffset = modelHeightOffset[currentModelPath] || 0;
                    this.mesh.position.set(path.x, heightOffset, path.z);
                    this.mesh.rotation.y = path.rotation;
                    
                    // èª¿è©¦ä¿¡æ¯
                    if (this.id < 4) {
                        const degrees = (path.rotation * 180 / Math.PI).toFixed(0);
                        const baseDegrees = (baseExtraRotation * 180 / Math.PI).toFixed(0);
                        const dirDegrees = (directionExtraRotation * 180 / Math.PI).toFixed(0);
                        console.log(`ğŸš— è»Šè¼› ${this.id} (${this.direction}): æ—‹è½‰=${degrees}åº¦ (åŸºç¤+${baseDegrees}åº¦+æ–¹å‘${dirDegrees}åº¦, æ¨¡å‹=${currentModelPath})`);
                    }
                }
            }

            update() {
                if (!this.mesh) return false;
                
                const distanceToStopLine = this.getDistanceToStopLine();
                const lightStatus = trafficLightStatus[this.direction];
                
                // æª¢æŸ¥è»Šè¼›æ˜¯å¦å·²ç¶“è¶Šéåœæ­¢ç·šï¼ˆé€²å…¥è·¯å£ï¼‰
                const hasPassedStopLine = this.hasPassedStopLine();
                
                // æœ€å„ªå…ˆï¼šå¦‚æœå·²ç¶“è¶Šéåœæ­¢ç·šï¼Œç„¡è«–ç‡ˆè™Ÿå¦‚ä½•éƒ½å¿…é ˆç¹¼çºŒé€šéè·¯å£ï¼ˆä¸èƒ½åœåœ¨è·¯å£ä¸­é–“ï¼‰
                if (hasPassedStopLine) {
                    // å·²è¶Šéåœæ­¢ç·šï¼Œå¿…é ˆç¹¼çºŒé€šéè·¯å£
                    this.speed = Math.min(this.maxSpeed, this.speed + this.acceleration);
                } else if (lightStatus === 'green') {
                    // ç¶ ç‡ˆä¸”é‚„æ²’è¶Šéåœæ­¢ç·šï¼ŒåŠ é€Ÿå‰é€²
                    this.speed = Math.min(this.maxSpeed, this.speed + this.acceleration);
                } else if (lightStatus === 'red' || lightStatus === 'yellow') {
                    // ç´…ç‡ˆæˆ–é»ƒç‡ˆï¼Œä¸”é‚„æ²’è¶Šéåœæ­¢ç·šï¼Œéœ€è¦åœæ­¢
                    if (distanceToStopLine <= 5) {
                        // è·é›¢åœæ­¢ç·š5å–®ä½ä»¥å…§ï¼Œç«‹å³åœæ­¢ï¼ˆç¢ºä¿åœåœ¨åœæ­¢ç·šä¹‹å‰ï¼‰
                        this.speed = 0;
                    } else if (distanceToStopLine < 20) {
                        // è·é›¢åœæ­¢ç·š20å–®ä½ä»¥å…§ï¼Œé–‹å§‹æ¼¸é€²æ¸›é€Ÿ
                        const slowdownFactor = (distanceToStopLine - 5) / 15; // 5-20å–®ä½ä¹‹é–“
                        const decelRate = this.deceleration * (2 - slowdownFactor); // è¶Šè¿‘æ¸›é€Ÿè¶Šå¿«
                        this.speed = Math.max(0, this.speed - decelRate);
                    } else {
                        // è·é›¢è¼ƒé ï¼ˆ>20å–®ä½ï¼‰ï¼Œæ­£å¸¸æ¸›é€Ÿ
                        this.speed = Math.max(0, this.speed - this.deceleration);
                    }
                } else {
                    // å…¶ä»–æƒ…æ³ï¼Œæ¸›é€Ÿåœæ­¢
                    this.speed = Math.max(0, this.speed - this.deceleration);
                }
                
                // æ›´æ–°ä½ç½®
                if (this.direction === 'north') {
                    this.mesh.position.z += this.speed;
                } else if (this.direction === 'south') {
                    this.mesh.position.z -= this.speed;
                } else if (this.direction === 'east') {
                    this.mesh.position.x -= this.speed;
                } else if (this.direction === 'west') {
                    this.mesh.position.x += this.speed;
                }
                
                return this.hasReachedEnd();
            }

            checkShouldStop() {
                const distanceToStopLine = this.getDistanceToStopLine();
                const lightStatus = trafficLightStatus[this.direction];
                
                // å¢å¼·èª¿è©¦ä¿¡æ¯ - é¡¯ç¤ºç´…ç‡ˆè»Šè¼›çš„è©³ç´°ç‹€æ…‹
                if ((lightStatus === 'red' || lightStatus === 'yellow') && distanceToStopLine >= 0 && this.speed > 0) {
                    console.log(`âš ï¸ ç´…ç‡ˆè»Šè¼›æª¢æ¸¬: è»Š ${this.id} (${this.direction}): ç‡ˆ=${lightStatus}, è·é›¢=${distanceToStopLine.toFixed(1)}, é€Ÿåº¦=${this.speed.toFixed(2)} â†’ æ‡‰è©²åœæ­¢`);
                }
                
                // å·²ç¶“è¶Šéåœæ­¢ç·šï¼Œä¸æ‡‰è©²åœæ­¢ï¼ˆå¿…é ˆé€šéè·¯å£ï¼‰
                if (this.hasPassedStopLine()) {
                    return false;
                }
                
                // å¦‚æœæ˜¯ç´…ç‡ˆæˆ–é»ƒç‡ˆï¼Œä¸”é‚„æ²’è¶Šéåœæ­¢ç·šï¼Œå¿…é ˆåœè»Š
                // åœ¨è·é›¢åœæ­¢ç·š5å–®ä½ä»¥å…§å°±å¿…é ˆåœè»Š
                if (lightStatus === 'red' || lightStatus === 'yellow') {
                    if (distanceToStopLine <= 5) {
                        return true; // è·é›¢åœæ­¢ç·š5å–®ä½ä»¥å…§ï¼Œå¼·åˆ¶åœè»Š
                    }
                    return true; // ç´…ç‡ˆæ™‚ç„¡è«–è·é›¢å¤šé éƒ½è¦æº–å‚™åœè»Š
                }
                
                // ç¶ ç‡ˆå¯ä»¥é€šé
                return false;
            }

            getDistanceToStopLine() {
                if (!this.mesh) return 100;
                
                const stopLines = {
                    north: -12,
                    south: 12,
                    east: 10,   // æ±å‘åœæ­¢ç·šåœ¨å³å´ï¼ˆè»Šè¼›å¾å³é‚Šä¾†ï¼Œåœåœ¨å³å´ï¼‰
                    west: -10   // è¥¿å‘åœæ­¢ç·šåœ¨å·¦å´ï¼ˆè»Šè¼›å¾å·¦é‚Šä¾†ï¼Œåœåœ¨å·¦å´ï¼‰
                };
                
                const stopLine = stopLines[this.direction];
                if (this.direction === 'north' || this.direction === 'south') {
                    // å—åŒ—å‘ï¼šè·é›¢ = åœæ­¢ç·šä½ç½® - è»Šè¼›ä½ç½®ï¼ˆæ­£æ•¸è¡¨ç¤ºé‚„æ²’åˆ°é”ï¼Œè² æ•¸è¡¨ç¤ºå·²è¶Šéï¼‰
                    return this.direction === 'north' 
                        ? stopLine - this.mesh.position.z 
                        : this.mesh.position.z - stopLine;
                } else {
                    // æ±è¥¿å‘ï¼šè·é›¢ = åœæ­¢ç·šä½ç½® - è»Šè¼›ä½ç½®ï¼ˆæ­£æ•¸è¡¨ç¤ºé‚„æ²’åˆ°é”ï¼Œè² æ•¸è¡¨ç¤ºå·²è¶Šéï¼‰
                    // ä½†è¦æ³¨æ„ï¼šeast å¾å³å‘å·¦ç§»å‹•ï¼ˆx å¾ 40 æ¸›åˆ° -40ï¼‰ï¼Œwest å¾å·¦å‘å³ç§»å‹•ï¼ˆx å¾ -40 åŠ åˆ° 40ï¼‰
                    if (this.direction === 'east') {
                        // east: åœæ­¢ç·š x=10ï¼Œè»Šè¼›å¾ x=40 å‘ x=-40 ç§»å‹•
                        // å¦‚æœ position.x <= 10ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·šï¼Œè·é›¢æ‡‰è©²æ˜¯è² æ•¸
                        // å¦‚æœ position.x > 10ï¼Œèªªæ˜é‚„æ²’åˆ°é”åœæ­¢ç·šï¼Œè·é›¢æ‡‰è©²æ˜¯æ­£æ•¸
                        return stopLine - this.mesh.position.x;
                    } else {
                        // west: åœæ­¢ç·š x=-10ï¼Œè»Šè¼›å¾ x=-40 å‘ x=40 ç§»å‹•
                        // å¦‚æœ position.x >= -10ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·šï¼Œè·é›¢æ‡‰è©²æ˜¯è² æ•¸
                        // å¦‚æœ position.x < -10ï¼Œèªªæ˜é‚„æ²’åˆ°é”åœæ­¢ç·šï¼Œè·é›¢æ‡‰è©²æ˜¯æ­£æ•¸
                        return this.mesh.position.x - stopLine;
                    }
                }
            }
            
            // æª¢æŸ¥è»Šè¼›æ˜¯å¦å·²ç¶“è¶Šéåœæ­¢ç·šï¼ˆé€²å…¥è·¯å£ï¼‰
            hasPassedStopLine() {
                if (!this.mesh) return false;
                
                const stopLines = {
                    north: -12,
                    south: 12,
                    east: 10,
                    west: -10
                };
                
                const stopLine = stopLines[this.direction];
                const pos = this.mesh.position;
                
                // æ ¹æ“šæ–¹å‘åˆ¤æ–·æ˜¯å¦è¶Šéåœæ­¢ç·š
                if (this.direction === 'north') {
                    // åŒ—å‘ï¼šå¾ z=-40 å‘ z=40 ç§»å‹•ï¼Œåœæ­¢ç·š z=-12
                    // å¦‚æœ z >= -12ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·š
                    return pos.z >= stopLine;
                } else if (this.direction === 'south') {
                    // å—å‘ï¼šå¾ z=40 å‘ z=-40 ç§»å‹•ï¼Œåœæ­¢ç·š z=12
                    // å¦‚æœ z <= 12ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·š
                    return pos.z <= stopLine;
                } else if (this.direction === 'east') {
                    // æ±å‘ï¼šå¾ x=40 å‘ x=-40 ç§»å‹•ï¼Œåœæ­¢ç·š x=10
                    // å¦‚æœ x <= 10ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·š
                    return pos.x <= stopLine;
                } else if (this.direction === 'west') {
                    // è¥¿å‘ï¼šå¾ x=-40 å‘ x=40 ç§»å‹•ï¼Œåœæ­¢ç·š x=-10
                    // å¦‚æœ x >= -10ï¼Œèªªæ˜å·²ç¶“è¶Šéåœæ­¢ç·š
                    return pos.x >= stopLine;
                }
                return false;
            }

            hasReachedEnd() {
                if (!this.mesh) return true;
                const pos = this.mesh.position;
                return Math.abs(pos.x) > 45 || Math.abs(pos.z) > 45;
            }

            remove() {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh = null;
                }
            }
        }

        function spawnVehicle(direction) {
            if (!systemStarted || !cybertruckModel) return;
            
            // é™åˆ¶æœ€å¤š 10 å°è»Š
            if (vehicles.length >= 10) {
                return;
            }
            
            // æª¢æŸ¥è©²æ–¹å‘èµ·é»å¾Œæ–¹æ˜¯å¦å·²ç¶“æœ‰è»Šè¼›ï¼ˆé¿å…é‡ç–Šï¼‰
            const spawnPositions = {
                north: { x: 3, z: -40 },
                south: { x: -3, z: 40 },
                east: { x: 40, z: 5 },
                west: { x: -40, z: -5 }
            };
            
            const spawnPos = spawnPositions[direction];
            const minSpawnDistance = 15; // æœ€å°ç”Ÿæˆé–“è·ï¼ˆå–®ä½ï¼‰- å¾10å¢åŠ åˆ°15ï¼Œç¢ºä¿è»Šè¼›é–“è·æ›´å¤§
            
            // åœæ­¢ç·šä½ç½®ï¼ˆç”¨æ–¼æª¢æŸ¥æ˜¯å¦æœ‰è»Šè¼›åœåœ¨åœæ­¢ç·šå‰ï¼‰
            const stopLines = {
                north: -12,
                south: 12,
                east: 10,
                west: -10
            };
            const stopLine = stopLines[direction];
            
            // æª¢æŸ¥è©²æ–¹å‘æ˜¯å¦æœ‰è»Šè¼›åœ¨ç”Ÿæˆä½ç½®é™„è¿‘æˆ–åœæ­¢ç·šé™„è¿‘ï¼ˆé¿å…é‡ç–Šï¼‰
            let canSpawn = true;
            for (let vehicle of vehicles) {
                if (vehicle.direction === direction && vehicle.mesh) {
                    const pos = vehicle.mesh.position;
                    let isTooClose = false;
                    let reason = '';
                    
                    // æ ¹æ“šæ–¹å‘åˆ¤æ–·è»Šè¼›æ˜¯å¦å¤ªè¿‘
                    if (direction === 'north') {
                        // åŒ—å‘ï¼šèµ·é» z=-40ï¼Œåœæ­¢ç·š z=-12
                        const xDistance = Math.abs(pos.x - spawnPos.x);
                        if (xDistance < 2) {
                            // åœ¨åŒä¸€è»Šé“
                            // æª¢æŸ¥1ï¼šç”Ÿæˆä½ç½®å¾Œæ–¹ï¼ˆz < -40 + minSpawnDistanceï¼‰
                            if (pos.z < spawnPos.z + minSpawnDistance) {
                                const distanceFromSpawn = Math.abs(pos.z - spawnPos.z);
                                if (distanceFromSpawn < minSpawnDistance) {
                                    isTooClose = true;
                                    reason = `ç”Ÿæˆä½ç½®å¾Œæ–¹ ${distanceFromSpawn.toFixed(1)}å–®ä½`;
                                }
                            }
                            // æª¢æŸ¥2ï¼šåœæ­¢ç·šé™„è¿‘ï¼ˆz åœ¨åœæ­¢ç·šé™„è¿‘ 3 å–®ä½å…§ï¼‰
                            if (pos.z >= stopLine - 3 && pos.z <= stopLine + 3) {
                                isTooClose = true;
                                reason = `åœæ­¢ç·šé™„è¿‘ (z=${pos.z.toFixed(1)})`;
                            }
                        }
                    } else if (direction === 'south') {
                        // å—å‘ï¼šèµ·é» z=40ï¼Œåœæ­¢ç·š z=12
                        const xDistance = Math.abs(pos.x - spawnPos.x);
                        if (xDistance < 2) {
                            if (pos.z > spawnPos.z - minSpawnDistance) {
                                const distanceFromSpawn = Math.abs(pos.z - spawnPos.z);
                                if (distanceFromSpawn < minSpawnDistance) {
                                    isTooClose = true;
                                    reason = `ç”Ÿæˆä½ç½®å¾Œæ–¹ ${distanceFromSpawn.toFixed(1)}å–®ä½`;
                                }
                            }
                            if (pos.z >= stopLine - 3 && pos.z <= stopLine + 3) {
                                isTooClose = true;
                                reason = `åœæ­¢ç·šé™„è¿‘ (z=${pos.z.toFixed(1)})`;
                            }
                        }
                    } else if (direction === 'east') {
                        // æ±å‘ï¼šèµ·é» x=40ï¼Œåœæ­¢ç·š x=10
                        const zDistance = Math.abs(pos.z - spawnPos.z);
                        if (zDistance < 2) {
                            // åœ¨åŒä¸€è»Šé“
                            // æª¢æŸ¥1ï¼šç”Ÿæˆä½ç½®å¾Œæ–¹ï¼ˆx > 40 - minSpawnDistanceï¼‰
                            if (pos.x > spawnPos.x - minSpawnDistance) {
                                const distanceFromSpawn = Math.abs(pos.x - spawnPos.x);
                                if (distanceFromSpawn < minSpawnDistance) {
                                    isTooClose = true;
                                    reason = `ç”Ÿæˆä½ç½®å¾Œæ–¹ ${distanceFromSpawn.toFixed(1)}å–®ä½`;
                                }
                            }
                            // æª¢æŸ¥2ï¼šåœæ­¢ç·šé™„è¿‘ï¼ˆx åœ¨åœæ­¢ç·šé™„è¿‘ 3 å–®ä½å…§ï¼‰
                            if (pos.x >= stopLine - 3 && pos.x <= stopLine + 3) {
                                isTooClose = true;
                                reason = `åœæ­¢ç·šé™„è¿‘ (x=${pos.x.toFixed(1)})`;
                            }
                        }
                    } else if (direction === 'west') {
                        // è¥¿å‘ï¼šèµ·é» x=-40ï¼Œåœæ­¢ç·š x=-10
                        const zDistance = Math.abs(pos.z - spawnPos.z);
                        if (zDistance < 2) {
                            if (pos.x < spawnPos.x + minSpawnDistance) {
                                const distanceFromSpawn = Math.abs(pos.x - spawnPos.x);
                                if (distanceFromSpawn < minSpawnDistance) {
                                    isTooClose = true;
                                    reason = `ç”Ÿæˆä½ç½®å¾Œæ–¹ ${distanceFromSpawn.toFixed(1)}å–®ä½`;
                                }
                            }
                            if (pos.x >= stopLine - 3 && pos.x <= stopLine + 3) {
                                isTooClose = true;
                                reason = `åœæ­¢ç·šé™„è¿‘ (x=${pos.x.toFixed(1)})`;
                            }
                        }
                    }
                    
                    // å¦‚æœè»Šè¼›å¤ªè¿‘ï¼Œä¸èƒ½ç”Ÿæˆ
                    if (isTooClose) {
                        canSpawn = false;
                        console.log(`â›” è»Š ${vehicle.id} (${direction}) ${reason}ï¼Œè·³éç”Ÿæˆ`);
                        break;
                    }
                }
            }
            
            // é¡å¤–æª¢æŸ¥ï¼šç¢ºä¿ç”Ÿæˆä½ç½®æœ¬èº«æ²’æœ‰è»Šè¼›ï¼ˆé˜²æ­¢å®Œå…¨é‡ç–Šï¼‰
            // åªæª¢æŸ¥åŒä¸€æ–¹å‘çš„è»Šè¼›ï¼Œé¿å…ä¸åŒæ–¹å‘çš„è»Šè¼›äº’ç›¸å¹²æ“¾
            for (let vehicle of vehicles) {
                if (vehicle.direction === direction && vehicle.mesh) {
                    const pos = vehicle.mesh.position;
                    const xDistance = Math.abs(pos.x - spawnPos.x);
                    const zDistance = Math.abs(pos.z - spawnPos.z);
                    // å¦‚æœåŒä¸€æ–¹å‘çš„è»Šè¼›åœ¨ç”Ÿæˆä½ç½®é™„è¿‘ï¼ˆ5å–®ä½å…§ï¼‰ï¼Œä¸èƒ½ç”Ÿæˆ
                    if (xDistance < 5 && zDistance < 5) {
                        canSpawn = false;
                        console.log(`â›” è»Š ${vehicle.id} (${direction}) åœ¨ç”Ÿæˆä½ç½® (${spawnPos.x}, ${spawnPos.z}) é™„è¿‘ (xå·®=${xDistance.toFixed(1)}, zå·®=${zDistance.toFixed(1)})ï¼Œè·³éç”Ÿæˆ`);
                        break;
                    }
                }
            }
            
            // å¦‚æœç”Ÿæˆä½ç½®é™„è¿‘æœ‰è»Šï¼Œè·³éé€™æ¬¡ç”Ÿæˆ
            if (!canSpawn) {
                return;
            }
            
            const vehicle = new Vehicle(nextVehicleId++, direction);
            vehicles.push(vehicle);
            console.log(`âœ… è»Š ${vehicle.id} (${direction}) ç”Ÿæˆæ–¼ä½ç½® (${spawnPos.x}, ${spawnPos.z})`);
            
            // èª¿è©¦ï¼šåˆ—å‡ºè©²æ–¹å‘æ‰€æœ‰è»Šè¼›çš„ä½ç½®
            const sameDirVehicles = vehicles.filter(v => v.direction === direction && v.mesh);
            if (sameDirVehicles.length > 1) {
                console.log(`   è©²æ–¹å‘å…±æœ‰ ${sameDirVehicles.length} è¼›è»Šï¼š`);
                sameDirVehicles.forEach(v => {
                    const p = v.mesh.position;
                    console.log(`     è»Š ${v.id}: (${p.x.toFixed(1)}, ${p.z.toFixed(1)})`);
                });
            }
            
            // ç•¶é”åˆ°ä¸Šé™æ™‚åœ¨æ§åˆ¶å°æç¤º
            if (vehicles.length === 10) {
                console.log('âš ï¸ å·²é”åˆ°è»Šè¼›ä¸Šé™ï¼ˆ10å°ï¼‰');
            }
        }

        function startSpawning(direction, level) {
            if (spawnIntervals[direction]) {
                clearInterval(spawnIntervals[direction]);
            }
            const rate = SPAWN_RATE[level];
            spawnIntervals[direction] = setInterval(() => {
                spawnVehicle(direction);
            }, rate);
            spawnVehicle(direction);
        }

        function startAllTraffic() {
            ['north', 'south', 'east', 'west'].forEach(direction => {
                startSpawning(direction, currentTrafficLevels[direction]);
            });
            addHistory('è»Šæµç³»çµ±å•Ÿå‹•');
        }

        function updateAllVehicles() {
            if (!systemStarted) return;
            
            vehicles = vehicles.filter(vehicle => {
                const reachedEnd = vehicle.update();
                if (reachedEnd) {
                    vehicle.remove();
                    return false;
                }
                return true;
            });
        }

        // ============================================
        // ç´…ç¶ ç‡ˆæ§åˆ¶
        // ============================================
        function setLight(direction, color) {
            trafficLightStatus[direction] = color;
            
            console.log(`è¨­ç½®ç´…ç¶ ç‡ˆ: ${direction} -> ${color}`);
            
            // æ›´æ–° Three.js å ´æ™¯ä¸­çš„ç‡ˆå…‰
            scene.traverse((obj) => {
                if (obj.userData && obj.userData.direction === direction) {
                    const isActive = obj.userData.type === color;
                    
                    if (isActive) {
                        // ç‡ˆå…‰äº®èµ·
                        const activeColors = {
                            red: { color: 0xff0000, emissive: 0xff0000 },
                            yellow: { color: 0xffff00, emissive: 0xffff00 },
                            green: { color: 0x00ff00, emissive: 0x00ff00 }
                        };
                        
                        const lightColor = activeColors[color];
                        if (lightColor && obj.material) {
                            obj.material.color.setHex(lightColor.color);
                            obj.material.emissive.setHex(lightColor.emissive);
                            obj.material.emissiveIntensity = 1;
                            obj.material.needsUpdate = true;
                            obj.userData.isOn = true;
                            console.log(`  âœ… ${direction} ${obj.userData.type} ç‡ˆäº®èµ·`);
                        }
                    } else {
                        // ç‡ˆå…‰é—œé–‰ï¼ˆæš—æ·¡ï¼‰
                        const offColors = {
                            red: 0x330000,
                            yellow: 0x333300,
                            green: 0x003300
                        };
                        
                        const offColor = offColors[obj.userData.type];
                        if (offColor !== undefined && obj.material) {
                            obj.material.color.setHex(offColor);
                            obj.material.emissive.setHex(0x000000);
                            obj.material.emissiveIntensity = 0;
                            obj.material.needsUpdate = true;
                            obj.userData.isOn = false;
                        }
                    }
                }
            });
            
            // æ›´æ–° UI
            const statusElement = document.getElementById(`light-status-${direction}`);
            if (statusElement) {
                if (color === 'red') {
                    statusElement.textContent = 'ğŸ”´';
                    statusElement.style.color = '#ff2d2d';
                } else if (color === 'yellow') {
                    statusElement.textContent = 'ğŸŸ¡';
                    statusElement.style.color = '#ffd000';
                } else if (color === 'green') {
                    statusElement.textContent = 'ğŸŸ¢';
                    statusElement.style.color = '#00ff5a';
                }
            }
        }

        function updateTrafficLights(direction, action) {
            console.log(`\nğŸš¦ ========== æ›´æ–°ç´…ç¶ ç‡ˆ ==========`);
            console.log(`   æ–¹å‘: ${direction}, å‹•ä½œ: ${action}`);
            
            // å…ˆå…¨éƒ¨è¨­ç‚ºç´…ç‡ˆ
            console.log(`   æ­¥é©Ÿ1: å…¨éƒ¨è¨­ç‚ºç´…ç‡ˆ`);
            ['north', 'south', 'east', 'west'].forEach(dir => {
                setLight(dir, 'red');
            });
            
            // æ ¹æ“š GPT æ±ºç­–è¨­å®šç¶ ç‡ˆï¼ˆäº’é–æ©Ÿåˆ¶ï¼‰
            if (action === 'GREEN') {
                if (direction === 'north-south') {
                    console.log(`   æ­¥é©Ÿ2: è¨­å®šå—åŒ—å‘ç¶ ç‡ˆ`);
                    setLight('north', 'green');
                    setLight('south', 'green');
                    console.log(`   äº’é–: æ±è¥¿å‘ä¿æŒç´…ç‡ˆ`);
                    // ç¢ºä¿æ±è¥¿å‘æ˜¯ç´…ç‡ˆ
                    setLight('east', 'red');
                    setLight('west', 'red');
                } else if (direction === 'east-west') {
                    console.log(`   æ­¥é©Ÿ2: è¨­å®šæ±è¥¿å‘ç¶ ç‡ˆ`);
                    setLight('east', 'green');
                    setLight('west', 'green');
                    console.log(`   äº’é–: å—åŒ—å‘ä¿æŒç´…ç‡ˆ`);
                    // ç¢ºä¿å—åŒ—å‘æ˜¯ç´…ç‡ˆ
                    setLight('north', 'red');
                    setLight('south', 'red');
                }
            }
            
            // ç¢ºèªç•¶å‰ç‹€æ…‹
            console.log(`   æœ€çµ‚ç‹€æ…‹:`, trafficLightStatus);
            console.log(`   âœ… åŒ—=${trafficLightStatus.north}, å—=${trafficLightStatus.south}, æ±=${trafficLightStatus.east}, è¥¿=${trafficLightStatus.west}`);
            console.log(`================================\n`);
        }

        // ============================================
        // UI æ§åˆ¶å‡½æ•¸
        // ============================================
        let countdownInterval = null;
        let currentCountdown = 0;

        window.updateTrafficValue = function(direction, value) {
            const level = trafficLevels[parseInt(value)];
            currentTrafficLevels[direction] = level;
            
            const valueElement = document.getElementById(`${direction}-value`);
            valueElement.textContent = trafficLabels[level];
            valueElement.className = `traffic-value ${level}`;
            
            if (systemStarted) {
                startSpawning(direction, level);
            }
        };

        window.submitTrafficData = async function() {
            if (!systemStarted) {
                if (!cybertruckModel) {
                    alert('è«‹ç­‰å¾…æ¨¡å‹è¼‰å…¥å®Œæˆ');
                    return;
                }
                startAllTraffic();
                systemStarted = true;
            }
            
            await requestTrafficDecision();
        };

        async function requestTrafficDecision() {
            const picoIP = getPicoIP();
            const picoPort = getPicoPort();
            const url = `http://${picoIP}:${picoPort}/traffic`;
            
            setStatus('processing', 'æ­£åœ¨è«‹æ±‚ AI æ±ºç­–...');
            
            const payload = {
                north: currentTrafficLevels.north,
                south: currentTrafficLevels.south,
                east: currentTrafficLevels.east,
                west: currentTrafficLevels.west,
                timestamp: new Date().toISOString()
            };
            
            addHistory(`è«‹æ±‚ AI æ±ºç­–: N=${payload.north}, S=${payload.south}, E=${payload.east}, W=${payload.west}`);
            
            const submitBtn = document.getElementById('submit-btn');
            submitBtn.disabled = true;
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                handleGPTResponse(data);
            } catch (error) {
                console.error('Error:', error);
                setStatus('error', `é€£ç·šéŒ¯èª¤: ${error.message}`);
                updateGPTContent(`ç„¡æ³•é€£ç·šåˆ° Pico W (${picoIP}:${picoPort})`, true);
                addHistory(`éŒ¯èª¤: ${error.message}`);
                setTimeout(() => simulateResponse(), 1000);
            } finally {
                submitBtn.disabled = false;
            }
        }

        function handleGPTResponse(data) {
            setStatus('connected', 'å·²é€£ç·š - æ”¶åˆ° AI æŒ‡ä»¤');
            const message = data.message || `æ–¹å‘: ${data.direction}\nå‹•ä½œ: ${data.action}\næ™‚é•·: ${data.duration} ç§’`;
            updateGPTContent(message);
            updateTrafficLights(data.direction, data.action);
            startCountdown(data.duration);
            addHistory(`AI æŒ‡ä»¤: ${data.direction} ${data.action} ${data.duration}s`);
        }

        function simulateResponse() {
            const direction = Math.random() > 0.5 ? 'north-south' : 'east-west';
            const duration = 15 + Math.floor(Math.random() * 10);
            const simulatedData = {
                direction,
                action: 'GREEN',
                duration,
                message: `ã€æ¨¡æ“¬æ¨¡å¼ã€‘\n\nç³»çµ±è‡ªå‹•åˆ‡æ›è‡³ ${direction === 'north-south' ? 'å—åŒ—å‘' : 'æ±è¥¿å‘'} é€šè¡Œ\næ™‚é•·: ${duration} ç§’`
            };
            handleGPTResponse(simulatedData);
        }

        function startCountdown(seconds) {
            if (countdownInterval) clearInterval(countdownInterval);
            currentCountdown = seconds;
            document.getElementById('countdown').textContent = currentCountdown;
            
            countdownInterval = setInterval(() => {
                currentCountdown--;
                document.getElementById('countdown').textContent = currentCountdown;
                
                if (currentCountdown === 3) {
                    ['north', 'south', 'east', 'west'].forEach(dir => {
                        if (trafficLightStatus[dir] === 'green') {
                            setLight(dir, 'yellow');
                        }
                    });
                }
                
                if (currentCountdown <= 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('countdown').textContent = '--';
                    ['north', 'south', 'east', 'west'].forEach(dir => {
                        setLight(dir, 'red');
                    });
                    addHistory('ç‡ˆè™Ÿé€±æœŸçµæŸ - ç­‰å¾…ä¸‹æ¬¡æŒ‡ä»¤');
                }
            }, 1000);
        }

        window.resetAllVehicles = function() {
            vehicles.forEach(vehicle => vehicle.remove());
            vehicles = [];
            
            ['north', 'south', 'east', 'west'].forEach(direction => {
                if (spawnIntervals[direction]) {
                    clearInterval(spawnIntervals[direction]);
                    spawnIntervals[direction] = null;
                }
            });
            
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            
            ['north', 'south', 'east', 'west'].forEach(dir => setLight(dir, 'red'));
            
            systemStarted = false;
            nextVehicleId = 0;
            currentCountdown = 0;
            document.getElementById('countdown').textContent = '--';
            
            setStatus('', 'æ‰€æœ‰è»Šè¼›å·²é‡ç½®ï¼Œç­‰å¾…è¨­å®šè»Šæµé‡...');
            addHistory('ğŸ”„ ç³»çµ±é‡ç½®å®Œæˆï¼Œæ‰€æœ‰è»Šè¼›å·²æ¸…é™¤');
        };

        function setStatus(status, text) {
            const dot = document.getElementById('status-dot');
            const textElement = document.getElementById('status-text');
            dot.className = `status-dot ${status}`;
            textElement.textContent = text;
        }

        function updateGPTContent(content, isError = false) {
            const element = document.getElementById('gpt-content');
            element.textContent = content;
            element.classList.toggle('placeholder', isError);
        }

        function addHistory(message) {
            const historyList = document.getElementById('history-list');
            const now = new Date();
            const timeStr = now.toLocaleTimeString('zh-TW');
            
            const item = document.createElement('div');
            item.className = 'history-item';
            item.innerHTML = `
                <div class="history-time">${timeStr}</div>
                <div>${message}</div>
            `;
            
            historyList.insertBefore(item, historyList.firstChild);
            while (historyList.children.length > 15) {
                historyList.removeChild(historyList.lastChild);
            }
        }

        // ============================================
        // æ¸¬è©¦è»ŠæµåŠŸèƒ½
        // ============================================
        window.testTrafficFlow = function(direction) {
            // å¦‚æœé‚„æ²’å•Ÿå‹•ç³»çµ±ï¼Œå…ˆå•Ÿå‹•
            if (!systemStarted) {
                if (!cybertruckModel) {
                    alert('âš ï¸ è«‹ç­‰å¾…æ¨¡å‹è¼‰å…¥å®Œæˆ');
                    return;
                }
                startAllTraffic();
                systemStarted = true;
                addHistory('ğŸš— æ¸¬è©¦æ¨¡å¼ï¼šè»Šæµç³»çµ±å·²å•Ÿå‹•');
            }
            
            // ä½¿ç”¨æŒ‡å®šçš„æ–¹å‘æ¸¬è©¦
            const directionName = direction === 'north-south' ? 'å—åŒ—å‘' : 'æ±è¥¿å‘';
            const directionIcon = direction === 'north-south' ? 'â¬' : 'â¬Œ';
            
            setStatus('processing', `æ¸¬è©¦æ¨¡å¼ï¼š${directionName} é‹è¡Œä¸­...`);
            addHistory(`ğŸ§ª æ¸¬è©¦æ¨¡å¼ï¼š${directionIcon} ${directionName} ç¶ ç‡ˆ`);
            
            const duration = 20; // å›ºå®š 20 ç§’ä¾¿æ–¼æ¸¬è©¦
            
            const testData = {
                direction: direction,
                action: 'GREEN',
                duration: duration,
                message: `ã€æ¸¬è©¦æ¨¡å¼ã€‘\n\n${directionIcon} ${directionName} é€šè¡Œ\næ™‚é•·: ${duration} ç§’\n\né€™æ˜¯æ¸¬è©¦æ¨¡å¼ï¼Œä¸æœƒé€£æ¥åˆ° Pico W`
            };
            
            handleGPTResponse(testData);
            setStatus('connected', `æ¸¬è©¦æ¨¡å¼ï¼š${directionName} é‹è¡Œä¸­`);
        };

        // ============================================
        // æ¨¡å‹åˆ‡æ›åŠŸèƒ½
        // ============================================
        window.switchModel = async function(modelPath) {
            // é¡¯ç¤ºè¼‰å…¥ä¸­
            const loadingOverlay = document.getElementById('loading');
            loadingOverlay.classList.remove('hidden');
            const loadingText = document.querySelector('.loading-text');
            loadingText.textContent = 'æ­£åœ¨åˆ‡æ›æ¨¡å‹...';
            loadingText.style.color = '';
            
            // ç§»é™¤æ‰€æœ‰ç¾æœ‰è»Šè¼›
            vehicles.forEach(vehicle => vehicle.remove());
            vehicles = [];
            
            // åœæ­¢ç”Ÿæˆæ–°è»Šè¼›
            ['north', 'south', 'east', 'west'].forEach(direction => {
                if (spawnIntervals[direction]) {
                    clearInterval(spawnIntervals[direction]);
                    spawnIntervals[direction] = null;
                }
            });
            
            // æš«åœç³»çµ±
            const wasStarted = systemStarted;
            systemStarted = false;
            
            // é‡æ–°è¼‰å…¥æ¨¡å‹
            loadCybertruckModel(modelPath);
            
            // ç­‰å¾…æ¨¡å‹è¼‰å…¥å®Œæˆå¾Œæ¢å¾©ç³»çµ±
            const checkModelLoaded = setInterval(() => {
                if (cybertruckModel) {
                    clearInterval(checkModelLoaded);
                    if (wasStarted) {
                        systemStarted = true;
                        startAllTraffic();
                    }
                    
                    // æ›´æ–°é¡¯ç¤ºä¿¡æ¯
                    const modelInfo = document.getElementById('model-info');
                    if (modelInfo) {
                        modelInfo.textContent = `ç•¶å‰æ¨¡å‹ï¼š${modelPath}`;
                    }
                    
                    addHistory(`ğŸ”„ å·²åˆ‡æ›æ¨¡å‹ï¼š${modelPath}`);
                }
            }, 100);
            
            // è¶…æ™‚è™•ç†ï¼ˆ10ç§’ï¼‰
            setTimeout(() => {
                clearInterval(checkModelLoaded);
            }, 10000);
        };

        // ============================================
        // åˆå§‹åŒ–
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            setStatus('', 'ç­‰å¾…è¨­å®šè»Šæµé‡...');
            addHistory('ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
            addHistory(`ç›®æ¨™è¨­å‚™: Pico W (${getPicoIP()}:${getPicoPort()})`);
            addHistory('è«‹è¨­å®š IP ä½å€ã€èª¿æ•´è»Šæµé‡ï¼Œç„¶å¾Œç™¼é€è‡³ Pico W');
            
            // ç•¶ IP æ”¹è®Šæ™‚æ›´æ–°æ­·å²è¨˜éŒ„
            document.getElementById('pico-ip-input').addEventListener('change', function() {
                addHistory(`ğŸ”„ æ›´æ–°ç›®æ¨™è¨­å‚™: ${getPicoIP()}:${getPicoPort()}`);
            });
        });
    </script>
</body>
</html>
